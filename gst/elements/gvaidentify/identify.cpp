/*******************************************************************************
 * Copyright (C) 2018-2020 Intel Corporation
 *
 * SPDX-License-Identifier: MIT
 ******************************************************************************/

#include "identify.h"

#include "config.h"
#include "gst/videoanalytics/video_frame.h"
#include "gstgvaidentify.h"

#include <opencv2/imgproc.hpp>
#include <vector>

#define UNUSED(x) (void)x

using namespace std::placeholders;

Identify::Identify(GstGvaIdentify *ovino) {
    masterGstElement_ = ovino;

    // Create gallery
    if (ovino->gallery) {
        double reid_threshold = ovino->cosine_dist_threshold;
        gallery = std::unique_ptr<EmbeddingsGallery>(
            new EmbeddingsGallery(GST_BASE_TRANSFORM_CAST(ovino), ovino->gallery, reid_threshold));
    }
}

Identify::~Identify() {
}

void Identify::IdentifyObjects(GstBuffer *buffer) {
    GVA::VideoFrame video_frame(buffer, masterGstElement_->info);
    std::vector<cv::Mat> embeddings;
    std::vector<GVA::Tensor> tensors;
    auto regions = video_frame.regions();

    // Find embeddings generated by gvaclassify
    for (GVA::RegionOfInterest &roi : regions) {
        // Find tensor generated by reidentification model
        for (GVA::Tensor &tensor : roi.tensors()) {
            if (masterGstElement_->model) {
                if (tensor.model_name().find(masterGstElement_->model) == std::string::npos)
                    continue;
            } else {
                if (tensor.format() != "cosine_distance")
                    continue;
            }

            // embeddings
            std::vector<float> data = tensor.data<float>();
            cv::Mat blob_wrapper(data.size(), 1, CV_32F, data.data());
            embeddings.emplace_back();
            blob_wrapper.copyTo(embeddings.back());
            // tensors
            tensors.push_back(tensor);
            break;
        }
    }

    // Compare embeddings against gallery
    auto ids = gallery->GetIDsByEmbeddings(embeddings);
    if (ids.size() != tensors.size())
        std::logic_error("The number of id received does not match the number of tensors!");

    // Store label for identified objects
    for (size_t i = 0; i < ids.size(); i++) {
        tensors[i].set_string("label", gallery->GetLabelByID(ids[i].first));
        if (ids[i].first != EmbeddingsGallery::unknown_id) {
            tensors[i].set_int("label_id", ids[i].first + 1); // recognized objects starting label_id=1
        } else {
            tensors[i].set_int("label_id", EmbeddingsGallery::unknown_id);
        }
        tensors[i].set_double("cos_dist", static_cast<double>(ids[i].second));
    }
}

void Identify::ProcessOutput(GstBuffer *buffer) {
    if (gallery) {
        IdentifyObjects(buffer);
    }
}

GstFlowReturn frame_to_identify(GstGvaIdentify *ovino, GstBuffer *buf) {
    try {
        ovino->identifier->ProcessOutput(buf);
    } catch (const std::exception &e) {
        GST_ELEMENT_ERROR(ovino, RESOURCE, SETTINGS, ("frame_to_identify has been failed."), ("%s", e.what()));
        return GST_FLOW_ERROR;
    }
    return GST_FLOW_OK;
}

Identify *identifier_new(GstGvaIdentify *ovino) {
    try {
        return new Identify(ovino);
    } catch (const std::exception &e) {
        GST_ELEMENT_ERROR(ovino, RESOURCE, SETTINGS, ("identifier_delete has been failed."), ("%s", e.what()));
        return nullptr;
    }
}

void identifier_delete(Identify *identifier) {
    try {
        delete identifier;
    } catch (const std::exception &e) {
        GST_ERROR("identifier_delete has been failed:%s", e.what());
    }
}
